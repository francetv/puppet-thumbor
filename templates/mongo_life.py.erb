#!/usr/bin/python2.7
from pymongo import *
from datetime import datetime
from datetime import timedelta
import os, sys
import getopt
import gridfs
import configparser

##############################
def main():
  version_s="1.0.135"
  path_result=""
  maintenance=""
  path_storage="aaa"
  try:
      opts, args = getopt.getopt(sys.argv[1:], "c:s:m:v")
  except getopt.GetoptError as err:
    sys.stdout = sys.stderr
    print """usage: %s [-c|-s|-m|-z] [file|-]
    -c <path> : purge du path dans le cache Mongodb
    -s <path> : purge du path dans le storage Mongodb
    -m : Effectue la maintenance de base Mongodb Index et coherence
    -v : Affiche la version"""%sys.argv[0]
    sys.exit(2)

  for o, a in opts:
    if o == "-c":
      path_result = a
      parameters = read_parameters('cache')
      result_purge = purge_cache(parameters, path_result)
      break
    elif o == "-s":
      path_storage = a
      parameters = read_parameters('storage')
      result_purge = purge_storage(parameters, path_storage)
      break
    elif o == "-m":
      maintenance = a
      parameters = read_parameters('all')
      result_maintenance = maintenance_tools(parameters)
      break
    elif o == "-v":
      print "Version %s "%version_s
      sys.exit(0)
    else:
      assert False, "Mauvaise option"
      sys.exit(2)



##############################
def read_parameters(comp):

  with open('/etc/thumbor/thumbor-8888.conf') as f:
    file_content = u'[main]\n' + f.read()

  config_parser = configparser.RawConfigParser()
  config_parser.read_string(file_content)

  if comp == 'cache':

    dictconfig = {
      "ttl_cache": config_parser.get('main','RESULT_STORAGE_EXPIRATION_SECONDS').replace("\"", ""),
      "mongo_cache_server": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_HOST').replace("\"", ""),
      "mongo_cache_user": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_USER').replace("\"", ""),
      "mongo_cache_pass": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_PASSWORD').replace("\"", ""),
      "mongo_cache_authdb": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_AUTH').replace("\"", ""),
      "mongo_cache_db": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_DB').replace("\"", ""),
      "mongo_cache_col": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_COLLECTION').replace("\"", ""),
      "mongo_cache_mod": config_parser.get('main','RESULT_STORAGE').replace("\"", "")
    }

  elif comp == 'storage':
    if config_parser.get('main','STORAGE', fallback='none').replace("\"", "") == 'thumbor_mongodb_storage_webp.storages.mongo_storage':

      dictconfig= {
        "ttl_storage": config_parser.get('main','STORAGE_EXPIRATION_SECONDS').replace("\"", ""),
        "ttl_cache": config_parser.get('main','RESULT_STORAGE_EXPIRATION_SECONDS').replace("\"", ""),
        "mongo_str_server": config_parser.get('main','MONGO_STORAGE_SERVER_HOST').replace("\"", ""),
        "mongo_str_user": config_parser.get('main','MONGO_STORAGE_SERVER_USER').replace("\"", ""),
        "mongo_str_pass": config_parser.get('main','MONGO_STORAGE_SERVER_PASSWORD').replace("\"", ""),
        "mongo_str_authdb": config_parser.get('main','MONGO_STORAGE_SERVER_AUTH').replace("\"", ""),
        "mongo_str_db": config_parser.get('main','MONGO_STORAGE_SERVER_DB').replace("\"", ""),
        "mongo_str_col": config_parser.get('main','MONGO_STORAGE_SERVER_COLLECTION').replace("\"", ""),
        "mongo_str_mod": config_parser.get('main','STORAGE').replace("\"", ""),
        # conf cache
        "mongo_cache_server": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_HOST').replace("\"", ""),
        "mongo_cache_user": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_USER').replace("\"", ""),
        "mongo_cache_pass": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_PASSWORD').replace("\"", ""),
        "mongo_cache_authdb": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_AUTH').replace("\"", ""),
        "mongo_cache_db": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_DB').replace("\"", ""),
        "mongo_cache_col": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_COLLECTION').replace("\"", ""),
        "mongo_cache_mod": config_parser.get('main','RESULT_STORAGE').replace("\"", "")
      }
    else:
      print "\033[31mSTORAGE - Cette fonction n'est pas compatible avec cette instance\033[0m"
      sys.exit(0)


  else:
    if config_parser.get('main','STORAGE', fallback='none').replace("\"", "") == 'thumbor_mongodb_storage_webp.storages.mongo_storage' and\
    config_parser.get('main','RESULT_STORAGE', fallback='none').replace("\"", "") == 'thumbor_mongodb_storage_webp.result_storages.mongo_result_storage':

      dictconfig= {
        # conf TTL
        "ttl_storage": config_parser.get('main','STORAGE_EXPIRATION_SECONDS').replace("\"", ""),
        "ttl_cache": config_parser.get('main','RESULT_STORAGE_EXPIRATION_SECONDS').replace("\"", ""),
        # conf storage
        "mongo_str_server": config_parser.get('main','MONGO_STORAGE_SERVER_HOST').replace("\"", ""),
        "mongo_str_user": config_parser.get('main','MONGO_STORAGE_SERVER_USER').replace("\"", ""),
        "mongo_str_pass": config_parser.get('main','MONGO_STORAGE_SERVER_PASSWORD').replace("\"", ""),
        "mongo_str_authdb": config_parser.get('main','MONGO_STORAGE_SERVER_AUTH').replace("\"", ""),
        "mongo_str_db": config_parser.get('main','MONGO_STORAGE_SERVER_DB').replace("\"", ""),
        "mongo_str_col": config_parser.get('main','MONGO_STORAGE_SERVER_COLLECTION').replace("\"", ""),
        "mongo_str_mod": config_parser.get('main','STORAGE').replace("\"", ""),
        # conf cache
        "mongo_cache_server": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_HOST').replace("\"", ""),
        "mongo_cache_user": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_USER').replace("\"", ""),
        "mongo_cache_pass": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_PASSWORD').replace("\"", ""),
        "mongo_cache_authdb": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_AUTH').replace("\"", ""),
        "mongo_cache_db": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_DB').replace("\"", ""),
        "mongo_cache_col": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_COLLECTION').replace("\"", ""),
        "mongo_cache_mod": config_parser.get('main','RESULT_STORAGE').replace("\"", ""),
        "instance_type": 'full'
      }


    else:
      dictconfig= {
        # conf TTL
        "ttl_cache": config_parser.get('main','RESULT_STORAGE_EXPIRATION_SECONDS').replace("\"", ""),
        # conf cache
        "mongo_cache_server": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_HOST').replace("\"", ""),
        "mongo_cache_user": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_USER').replace("\"", ""),
        "mongo_cache_pass": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_PASSWORD').replace("\"", ""),
        "mongo_cache_authdb": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_AUTH').replace("\"", ""),
        "mongo_cache_db": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_DB').replace("\"", ""),
        "mongo_cache_col": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_COLLECTION').replace("\"", ""),
        "mongo_cache_mod": config_parser.get('main','RESULT_STORAGE').replace("\"", ""),
        "instance_type": 'simple'
      }

  return dictconfig

##############################
def con_mongo(parameters, env):

  if (parameters['mongo_cache_mod'] == 'thumbor_mongodb_storage.result_storages.mongo_result_storage'\
    or parameters['mongo_cache_mod'] == 'thumbor_mongodb_storage_webp.result_storages.mongo_result_storage')\
    and env == 'cache':
    uri2 = "mongodb://" + parameters['mongo_cache_user'] + ":" + parameters['mongo_cache_pass'] + "@" + parameters['mongo_cache_server'] \
    + "/?authSource=" + parameters['mongo_cache_authdb'] #+ "&replicaSet=education-preprod"
    instance = MongoClient(uri2)
    return instance
  elif (parameters['mongo_str_mod'] == 'thumbor_mongodb_storage.storages.mongo_storage'\
    or parameters['mongo_str_mod'] == 'thumbor_mongodb_storage_webp.storages.mongo_storage')\
    and env == 'storage':
    uri2 = "mongodb://" + parameters['mongo_str_user'] + ":" + parameters['mongo_str_pass'] + "@" + parameters['mongo_str_server'] \
    + "/?authSource=" + parameters['mongo_str_authdb'] #+ "&replicaSet=education-preprod"
    instance = MongoClient(uri2)
    return instance
  else:
    return None

##############################
def purge_cache(parameters, path):

  client = con_mongo(parameters, 'cache')
  db2 = client[parameters['mongo_cache_db']]
  completed_path= "result:" + path

  if db2[parameters['mongo_cache_col']].find_one({'path': completed_path}):
    db2[parameters['mongo_cache_col']].delete_one({'path': completed_path})
    print "\033[32mCACHE - Objet:", completed_path, " supprime \033[0m"
  else:
    print "\033[32m CACHE - Objet:", path, " non trouve \033[0m"
  sys.exit(0)

##############################
def purge_storage(parameters, path):

  client = con_mongo(parameters, 'storage')
  db2 = client[parameters['mongo_str_db']]

  if db2[parameters['mongo_str_col']].find_one({'path': path}):
    collection = db2.fs.files
    scan = db2[parameters['mongo_str_col']].find_one({'path': path})
    db2[parameters['mongo_str_col']].delete_one({'_id': scan['_id']})
    result = collection.find({"_id": scan['file_id']})
    imgfs = 0
    for doc in result:
      files_id = doc['_id']
      fs = gridfs.GridFS(db2)
      fs.delete(files_id)
      imgfs = imgfs + 1

    client2 = con_mongo(parameters, 'cache')
    db3 = client[parameters['mongo_cache_db']]
    coll3 =  db3[parameters['mongo_cache_col']]
    x = 0
    x = coll3.delete_many({'ref_id': path})
    print "\033[32mSTORAGE - Objet:", path, " supprime, " , imgfs , " chunk," , x.deleted_count ," images associees en cache\033[0m"
  else:
    print "\033[32mSTORAGE - Objet:", path, " non trouve \033[0m"


  sys.exit(0)

##############################
def maintenance_tools(parameters):

  print "\033[35mSTORAGE####################### Verification de l'index de recherche.....##############################\033[0m"
  if parameters['instance_type'] == 'full':
    client = con_mongo(parameters, 'storage')
    if client:
      db2 = client[parameters['mongo_str_db']]
      resp = db2[parameters['mongo_str_col']].index_information()
      col = db2[parameters['mongo_str_col']]
      if  resp.get('moteur'):
        print "\033[32mSTORAGE - Index de performance present \033[0m"
      else:
        print "\033[31mSTORAGE - L'index de performance n'est pas present dans la collection\033[0m"
        print "\033[32mSTORAGE - Creation de l'index de performance\033[0m"
        col.create_index([('path', ASCENDING)], name='moteur')

      print ("\033[32mSTORAGE - index performance: \033[0m")
      print ("\033[32m*************************************************************\033[0m")
      resp = db2.images.index_information()
      print resp.get('moteur')
      print ("\033[32m*************************************************************\033[0m")
      print "\033[32mSTORAGE - Fin de la verification index de performance\033[0m"
      imgc=0
      imgfs=0
      goodst=0
      gooph=0
      col7 = db2[parameters['mongo_str_col']]
      print "\033[32mSTORAGE - Supression des images et chunks associes \033[0m"
      today = datetime.today()
      ttl_removefs = int(parameters['ttl_storage'],10)/86400
      # Recherche dans la collection image les images vieilles
      resultimg = col7.find({"created_at": {"$lt": today - timedelta(ttl_removefs)}})
      collection = db2.fs.files
      # Recherche les fragments gridFS correspondants
      for img in resultimg:
        col7.delete_one({"_id": img['_id']})
        result = collection.find({"_id": img['file_id']})
        imgc = imgc + 1
        for doc in result:
          files_id = doc['_id']
          fs = gridfs.GridFS(db2)
          fs.delete(files_id)
          imgfs = imgfs + 1
      print "\033[32mINFO - Fin de purge du stocage -" + str(imgc) + " images / -" + str(imgfs) + " chuncks\033[0m"
    else:
      print "\033[31mSTORAGE - Cette fonction n'ets pas compatible avec cette instance\033[0m"


  print "\033[35mCACHE############################# Verification de l'index TTL.....###################################\033[0m"
  client2 = con_mongo(parameters, 'cache')
  if client2:
    db3 = client2[parameters['mongo_cache_db']]
    resp2 = db3[parameters['mongo_cache_col']].index_information()
    col2= db3[parameters['mongo_cache_col']]
    tta2= int(parameters['ttl_cache'],10)
    if resp2.get('purge'):
      print "\033[32mCACHE - Index TTL present\033[0m"
      eee2 = resp2.get('purge')
      aaa2 = int(eee2['expireAfterSeconds']);
      #aaa2 = map(int ,eee2['expireAfterSeconds']);
      if aaa2 >> tta2:
        print "\033[34mCACHE - Le TTL en base (",aaa2,") est superieur a la configuration (", parameters['ttl_cache'],"\033[0m)"
        print "\033[32mCACHE - Supression de l'index de purge\033[0m"
        col2.drop_index('purge')
        col2.create_index([('created_at', ASCENDING)], name='purge', expireAfterSeconds=tta2)
      elif aaa2 == tta2:
        print "\033[32mCACHE - Le TTL en base (",aaa2,") est identique a la configuration (",parameters['ttl_cache'],")\033[0m"
      else:
        print "\033[34mCACHE - Le TTL en base (",aaa2,") est inferieur a la configuration (",parameters['ttl_cache'],")\033[0m"
        col2.drop_index('purge')
        col2.create_index([('created_at', ASCENDING)], name='purge', expireAfterSeconds=tta2)
    else:
      print "\033[31mCACHE - L'index de purge n'est pas present dans la collection\033[0m"
      col2.create_index([('created_at', ASCENDING)], name='purge', expireAfterSeconds=tta2)

    print "\033[35mCACHE######################### Verification de l'index de recherche.....##############################\033[0m"
    if  resp2.get('moteur'):
      print "\033[32mCACHE - Index de performance present\033[0m"
    else:
      print "\033[31mCACHE - L'index de performance n'est pas present dans la collection\033[0m"
      print "\033[32mCACHE - Creation de l'index de performance\033[0m"
      col2.create_index([('path', ASCENDING)], name='moteur')

    if  resp2.get('rmv'):
      print "\033[32mCACHE - Index de performance II present\033[0m"
    else:
      print "\033[31mCACHE - L'index de performance II n'est pas present dans la collection\033[0m"
      print "\033[32mCACHE - Creation de l'index de performance II\033[0m"
      col2.create_index([('ref_id', ASCENDING)], name='rmv')

    print ("\033[32mCACHE - index performance: \033[0m")
    print ("\033[32m*************************************************************\033[0m")
    resp2 = db3[parameters['mongo_cache_col']].index_information()
    print resp2.get('moteur')
    print resp2.get('rmv')
    print ("\033[32m*************************************************************\033[0m")
    print "\033[32mCACHE - Fin de la verification index de performance\033[0m"
  else:
    print "\033[31mCACHE - Cette fonction n'ets pas compatible avec cette instance\033[0m"

##############################
main()
