#!/usr/bin/python2.7
from pymongo import *
from datetime import datetime
from datetime import timedelta
import os, sys
import getopt
import gridfs
import configparser

##############################
def main():
  path_result=""
  maintenance=""
  path_storage="aaa"
  try:
    opts, args = getopt.getopt(sys.argv[1:], "c:s:m")
  except getopt.GetoptError as err:   
    sys.stdout = sys.stderr    
    print """usage: %s [-c|-s|-m] [file|-]
    -c <path> : purge du path dans le cache Mongodb
    -s <path> : purge du path dans le storage Mongodb
    -m : Effectue la maintenance de base Mongodb Index et coherence'"""%sys.argv[0]
    sys.exit(2)

  for o, a in opts:
    if o == "-c":
      path_result = a
      parameters = read_parameters()
      result_purge = purge_cache(parameters, path_result)
      break
    elif o == "-s":
      path_storage = a
      parameters = read_parameters('storage')
      result_purge = purge_storage(parameters, path_storage)
      break
    elif o == "-m":
      maintenance = a
      parameters = read_parameters()
      result_maintenance = maintenance_tools(parameters)
      break
    else:
      assert False, "Mauvaise option"
      sys.exit(2)
  
  
##############################
def read_parameters(*comp):
  
  with open('/etc/thumbor/thumbor-8888.conf') as f:
    file_content = u'[main]\n' + f.read()

  config_parser = configparser.RawConfigParser()
  config_parser.read_string(file_content)

  if comp == 'cache':
    
    dictconfig = {
      "mongo_cache_server": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_HOST').replace("\"", ""),
      "mongo_cache_user": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_USER').replace("\"", ""),
      "mongo_cache_pass": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_PASSWORD').replace("\"", ""),
      "mongo_cache_authdb": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_AUTH').replace("\"", ""),
      "mongo_cache_db": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_DB').replace("\"", ""),
      "mongo_cache_col": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_COLLECTION').replace("\"", ""),
      "mongo_cache_mod": config_parser.get('main','RESULT_STORAGE').replace("\"", "")
    }
    
  elif comp == 'storage':
    
    dictconfig= {
      "mongo_str_server": config_parser.get('main','MONGO_STORAGE_SERVER_HOST').replace("\"", ""),
      "mongo_str_user": config_parser.get('main','MONGO_STORAGE_SERVER_USER').replace("\"", ""),
      "mongo_str_pass": config_parser.get('main','MONGO_STORAGE_SERVER_PASSWORD').replace("\"", ""),
      "mongo_str_authdb": config_parser.get('main','MONGO_STORAGE_SERVER_AUTH').replace("\"", ""),
      "mongo_str_db": config_parser.get('main','MONGO_STORAGE_SERVER_DB').replace("\"", ""),
      "mongo_str_col": config_parser.get('main','MONGO_STORAGE_SERVER_COLLECTION').replace("\"", ""),
      "mongo_str_mod": config_parser.get('main','STORAGE').replace("\"", "")
    }
    
  else:
    
    dictconfig= {
      # conf TTL
      "ttl_storage": config_parser.get('main','STORAGE_EXPIRATION_SECONDS').replace("\"", ""),
      "ttl_cache": config_parser.get('main','RESULT_STORAGE_EXPIRATION_SECONDS').replace("\"", ""),
      # conf storage
      "mongo_str_server": config_parser.get('main','MONGO_STORAGE_SERVER_HOST').replace("\"", ""),
      "mongo_str_user": config_parser.get('main','MONGO_STORAGE_SERVER_USER').replace("\"", ""),
      "mongo_str_pass": config_parser.get('main','MONGO_STORAGE_SERVER_PASSWORD').replace("\"", ""),
      "mongo_str_authdb": config_parser.get('main','MONGO_STORAGE_SERVER_AUTH').replace("\"", ""),
      "mongo_str_db": config_parser.get('main','MONGO_STORAGE_SERVER_DB').replace("\"", ""),
      "mongo_str_col": config_parser.get('main','MONGO_STORAGE_SERVER_COLLECTION').replace("\"", ""),
      "mongo_str_mod": config_parser.get('main','STORAGE').replace("\"", ""),
      # conf cache
      "mongo_cache_server": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_HOST').replace("\"", ""),
      "mongo_cache_user": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_USER').replace("\"", ""),
      "mongo_cache_pass": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_PASSWORD').replace("\"", ""),
      "mongo_cache_authdb": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_AUTH').replace("\"", ""),
      "mongo_cache_db": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_DB').replace("\"", ""),
      "mongo_cache_col": config_parser.get('main','MONGO_RESULT_STORAGE_SERVER_COLLECTION').replace("\"", ""),
      "mongo_cache_mod": config_parser.get('main','RESULT_STORAGE').replace("\"", "")
    }
    
  return dictconfig
  
##############################
def con_mongo(parameters, env):
  
  if (parameters['mongo_cache_mod'] == 'thumbor_mongodb_storage.result_storages.mongo_result_storage'\
    or parameters['mongo_cache_mod'] == 'thumbor_mongodb_storage_webp.result_storages.mongo_result_storage')\
    and env == 'cache':
    uri2 = "mongodb://" + parameters['mongo_cache_user'] + ":" + parameters['mongo_cache_pass'] + "@" + parameters['mongo_cache_server'] \
    + "/?authSource=" + parameters['mongo_cache_authdb'] #+ "&replicaSet=education-preprod"
    instance = MongoClient(uri2)
    return instance
  elif (parameters['mongo_str_mod'] == 'thumbor_mongodb_storage.storages.mongo_storage'\
    or parameters['mongo_str_mod'] == 'thumbor_mongodb_storage_webp.storages.mongo_storage')\
    and env == 'storage':
    uri2 = "mongodb://" + parameters['mongo_str_user'] + ":" + parameters['mongo_str_pass'] + "@" + parameters['mongo_str_server'] \
    + "/?authSource=" + parameters['mongo_str_authdb'] #+ "&replicaSet=education-preprod"
    instance = MongoClient(uri2)
    return instance
  else:
    return None

##############################
def purge_cache(parameters, path):
  
  client = con_mongo(parameters, 'cache')
  db2 = client[parameters['mongo_cache_db']]
  completed_path= "result:" + path
  
  if db2.images_cache.find_one({'path': completed_path}):
    db2.images_cache.delete_one({'path': completed_path})
    print "\033[32mCACHE - Objet:", completed_path, " supprime\033[0m"
  else:
    print "\031[31mCACHE - Objet:", path, " non trouve\033[0m"
  sys.exit(0)

##############################
def purge_storage(parameters, path):
  
  client = con_mongo(parameters, 'storage')
  db2 = client[parameters['mongo_str_db']]
  
  if db2.images.find_one({'path': path}):
    collection = db2.fs.files
    scan = db2.images.find_one({'path': path})
    db2.images.delete_one({'_id': scan['_id']})
    result = collection.find({"_id": scan['file_id']})
    imgfs = 0
    for doc in result:
      files_id = doc['_id']
      fs = gridfs.GridFS(db2)
      fs.delete(files_id)
      imgfs = imgfs + 1
    
    client2 = con_mongo(parameters, 'cache')
    db3 = client[parameters['mongo_cache_db']]
    coll3 =  db3[parameters['mongo_cache_col']]
    x = 0
    x = coll3.delete_many({'ref_id': path})
    print "\033[32mSTORAGE - Objet:", path, " supprime, " , imgfs , " chunk," , x.deleted_count ," images associees en cache\033[0m"
  else:
    print "\031[31mSTORAGE - Objet:", path, " non trouve\033[0m"

  
  sys.exit(0)

##############################
def maintenance_tools(parameters):
  
  print "\033[35mSTORAGE####################### Verification de l'index de recherche.....##############################\033[0m"
  client = con_mongo(parameters, 'storage')
  if client:
    db2 = client[parameters['mongo_str_db']]
    resp = db2.images.index_information()
    col = db2[parameters['mongo_str_col']]
    if  resp.get('moteur'):
      print "\033[32mSTORAGE - Index de performance present \033[0m"
    else:
      print "\033[31mSTORAGE - L'index de performance n'est pas present dans la collection\033[0m"
      print "\033[32mSTORAGE - Creation de l'index de performance\033[0m"
      col.create_index([('path', ASCENDING)], name='moteur')
    
    print ("\033[32mSTORAGE - index performance: \033[0m")
    print ("\033[32m*************************************************************\033[0m")
    resp = db2.images.index_information()
    print resp.get('moteur')
    print ("\033[32m*************************************************************\033[0m")
    print "\033[32mSTORAGE - Fin de la verification index de performance\033[0m"
    imgc=0
    imgfs=0
    goodst=0
    gooph=0
    col7 = db2[parameters['mongo_str_col']]
    print "\033[32mSTORAGE - Supression des images et chunks associes \033[0m"
    today = datetime.today()
    ttl_removefs = int(parameters['ttl_storage'],10)/86400
    # Recherche dans la collection image les images vieilles
    resultimg = col7.find({"created_at": {"$lt": today - timedelta(days=ttl_removefs)}})
    collection = db2.fs.files
    # Recherche les fragments gridFS correspondants
    for img in resultimg:
      col7.delete_one({"_id": img['_id']})
      result = collection.find({"_id": img['file_id']})
      imgc = imgc + 1
      for doc in result:
        files_id = doc['_id']
        fs = gridfs.GridFS(db2)
        fs.delete(files_id)
        imgfs = imgfs + 1
    print "\033[32mINFO - Fin de purge du stocage -" + str(imgc) + " images / -" + str(imgfs) + " chuncks\033[0m"
  else:
    print "\033[31mSTORAGE - Cette fonction n'ets pas compatible avec cette instance\033[0m"
    
    
  print "\033[35mCACHE############################# Verification de l'index TTL.....###################################\033[0m"
  client2 = con_mongo(parameters, 'cache')
  if client2:
    db3 = client2[parameters['mongo_cache_db']]
    resp2 = db3.images_cache.index_information()
    col2= db3[parameters['mongo_cache_col']]
    if resp2.get('purge'):
      print "\033[32mCACHE - Index TTL present\033[0m"
      eee2 = resp2.get('purge')
      aaa2 = map(int ,eee2['expireAfterSeconds']);
      tta2= int(parameters['ttl_cache'],10)
      if aaa2[0] >> tta2:
        print "\033[34mCACHE - Le TTL en base (",aaa2[0],") est superieur a la configuration (", parameters['ttl_cache'],"\033[0m)"
        print "\033[32mCACHE - Supression de l'index de purge\033[0m"
        col2.drop_index('purge')
        col2.create_index([('created_at', ASCENDING)], name='purge', expireAfterSeconds=[parameters['ttl_cache']])
      elif aaa2[0] == tta2:
        print "\033[32mCACHE - Le TTL en base (",aaa2[0],") est identique a la configuration (",parameters['ttl_cache'],")\033[0m"
      else:
        print "\033[34mCACHE - Le TTL en base (",aaa2[0],") est inferieur a la configuration (",parameters['ttl_cache'],")\033[0m"
        col2.drop_index('purge')
        col2.create_index([('created_at', ASCENDING)], name='purge', expireAfterSeconds=[parameters['ttl_cache']])
    else:
      print "\033[31mCACHE - L'index de purge n'est pas present dans la collection\033[0m"
      col2.create_index([('created_at', ASCENDING)], name='purge', expireAfterSeconds=[parameters['ttl_cache']])
      
    print "\033[35mCACHE######################### Verification de l'index de recherche.....##############################\033[0m"
    if  resp2.get('moteur'):
      print "\033[32mCACHE - Index de performance present\033[0m"
    else:
      print "\033[31mCACHE - L'index de performance n'est pas present dans la collection\033[0m"
      print "\033[32mCACHE - Creation de l'index de performance\033[0m"
      col2.create_index([('path', ASCENDING)], name='moteur')
    
    if  resp2.get('rmv'):
      print "\033[32mCACHE - Index de performance II present\033[0m"
    else:
      print "\033[31mCACHE - L'index de performance II n'est pas present dans la collection\033[0m"
      print "\033[32mCACHE - Creation de l'index de performance II\033[0m"
      col2.create_index([('ref_id', ASCENDING)], name='rmv')
    
    print ("\033[32mCACHE - index performance: \033[0m")
    print ("\033[32m*************************************************************\033[0m")
    resp2 = db3.images_cache.index_information()
    print resp2.get('moteur')
    print resp2.get('rmv')
    print ("\033[32m*************************************************************\033[0m")
    print "\033[32mCACHE - Fin de la verification index de performance\033[0m"
  else:
    print "\033[31mCACHE - Cette fonction n'ets pas compatible avec cette instance\033[0m"

##############################
main()
